describe("lredis.cqueues module", function()
	local lc = require "lredis.cqueues"
	local cqueues = require "cqueues"
	local cs = require "cqueues.socket"
	it(":close closes the socket", function()
		local c, s = cs.pair()
		local r = lc.new(c)
		r:close()
		assert.same(nil, s:read())
		s:close()
	end)
	it(":ping works", function()
		local c, s = cs.pair()
		local r = lc.new(c)
		local cq = cqueues.new()
		cq:wrap(function()
			assert(r:ping() == "PONG")
		end)
		cq:wrap(function()
			assert(s:xwrite("+PONG\r\n", "bn"))
		end)
		assert(cq:loop(1))
		assert(cq:empty())
		r:close()
		s:close()
	end)
	it(":ping works outside of coroutine", function()
		local c, s = cs.pair()
		local r = lc.new(c)
		assert(s:xwrite("+PONG\r\n", "bn"))
		assert(r:ping() == "PONG")
		r:close()
		s:close()
	end)
	it("supports pipelining", function()
		local c, s = cs.pair()
		local r = lc.new(c)
		local cq = cqueues.new()
		cq:wrap(function()
			assert(r:ping() == "PONG1")
		end)
		cq:wrap(function()
			cqueues.sleep(0.01)
			assert(r:ping() == "PONG2")
		end)
		cq:wrap(function()
			cqueues.sleep(0.02)
			assert(s:xwrite("+PONG1\r\n", "bn"))
			assert(s:xwrite("+PONG2\r\n", "bn"))
		end)
		assert(cq:loop(1))
		assert(cq:empty())
		r:close()
		s:close()
	end)
	it("supports pubsub", function()
		local c, s = cs.pair()
		local r = lc.new(c)
		local cq = cqueues.new()
		cq:wrap(function()
			r:subscribe("foo")
			assert.same({"subscribe", "foo", 1}, r:get_next())
			assert.same({"publish", "foo", "message"}, r:get_next())
			r:unsubscribe("foo")
			assert.same({"unsubscribe", "foo", 0}, r:get_next())
			assert.same(nil, r:get_next())
		end)
		cq:wrap(function()
			assert(s:xwrite("*3\r\n$9\r\nsubscribe\r\n$3\r\nfoo\r\n:1\r\n", "bn"))
			assert(s:xwrite("*3\r\n$7\r\npublish\r\n$3\r\nfoo\r\n$7\r\nmessage\r\n", "bn"))
			assert(s:xwrite("*3\r\n$11\r\nunsubscribe\r\n$3\r\nfoo\r\n:0\r\n", "bn"))
		end)
		assert(cq:loop(1))
		assert(cq:empty())
		r:close()
		s:close()
	end)
	it("supports transactions", function()
		local c, s = cs.pair()
		local r = lc.new(c)
		local cq = cqueues.new()
		cq:wrap(function()
			local t = r:multi()
			assert(t)
			assert.same("QUEUED", t:ping())
			assert.same({{ok="PONG"}}, t:exec())
		end)
		cq:wrap(function()
			assert(s:xwrite("+OK\r\n", "bn"))
			assert(s:xwrite("+QUEUED\r\n", "bn"))
			assert(s:xwrite("*1\r\n+PONG\r\n", "bn"))
		end)
		assert(cq:loop(1))
		assert(cq:empty())
		r:close()
		s:close()
	end)
	it("works when you mix pubsub and transactions", function()
		local c, s = cs.pair()
		local r = lc.new(c)
		local cq = cqueues.new()
		cq:wrap(function()
			local t = r:multi()
			assert(t)
			t:subscribe("test")
			assert.same({{"subscribe", "test", 1}}, t:exec())
		end)
		cq:wrap(function()
			assert(s:xwrite("+OK\r\n", "bn"))
			assert(s:xwrite("+QUEUED\r\n", "bn"))
			assert(s:xwrite("*1\r\n*3\r\n$9\r\nsubscribe\r\n$4\r\ntest\r\n:1\r\n", "bn"))
		end)
		assert(cq:loop(1))
		assert(cq:empty())
		r:close()
		s:close()
	end)
	it("has working connect_tcp constructor", function()
		local m = cs.listen{host="127.0.0.1", port="0"}
		local _, host, port = m:localname()
		local cq = cqueues.new()
		cq:wrap(function()
			local r = lc.connect_tcp(host, port)
			r:ping()
			r:close()
		end)
		cq:wrap(function()
			local s = m:accept()
			assert(s:xwrite("+PONG\r\n", "bn"))
			s:close()
		end)
		assert(cq:loop(1))
		assert(cq:empty())
	end)
end)
